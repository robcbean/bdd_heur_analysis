typedef unsigned int uint32_t;



#include "mtrInt.h"
#include "cuddObj.hh"
#include "output.h"
#include "operations.h"
#include <sys/types.h>
#include <sys/wait.h>
#include <vector>
#include <iostream>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void timeOut()
{
  std::vector<BDD> output;
  Cudd mgr(0,0);
  print_output(<%= circuit.var_list.size() %>,"<%= circuit.name %>","<%= heur.print_name %>\t<%= reorder %>\t-1.0\t-1.0\t<%= span[heur.name] %>\t<%= circuit.extra_info.ecr %>\t<%= FunctionInfo.new(circuit).to_s %>",mgr,output,false,NULL,<%= calcTotal(circuit) %>);
}


int main( int argc, char **argv )
{

  Cudd mgr(<%=circuit.dfs_inputs.size%>,0);
  <%if not enable_autodyn %>
    mgr.AutodynDisable();
  <%else%>
    mgr.AutodynEnable(<%=heur.reorder%>);
  <%end%>
  double nodes_before=0;
  BDD x[<%=circuit.var_list.size()%>];
  double t1,t2,t3,t4;
  double  desc_t1=0,desc_t2=0,desc_t3=0,desc_t4=0,desc_t5=0;
  double  sum_nodes=0;
  DdNode* poutput[<%=circuit.outputs.size()-1%>];
  DdNode* ptotal[1];
  std::string str_output;
  char buffer[100];
  std::string grown="";
  std::string symmetric =  "";
  std::string symmetric_after = "";
  double minTerms=0;

  <%if calc_desc %>
  unsigned int core=0,dead=0;
  <%end %>

  //Timeout process control
  pid_t child_pid = fork();
  pid_t parent_pid = getpid();
  int status;
  if( child_pid != 0 )
  {
    sleep(<%=_wait_time%>);
    timeOut();
    kill(child_pid,SIGTERM);
    exit(0);
  }

  //Output nodes
  std::vector<BDD> output(<%= circuit.outputs.size()-1%>);
  std::vector<BDD> count_nodes_vector;
  std::vector<unsigned long> count_nodes;
  std::vector<unsigned long> count_id;

  for(unsigned int i=0; i<<%=circuit.outputs.size-1%>;i++)
  {
    output[i] = mgr.bddOne();
  }


  //Variables
<%circuit.getDFSOrderInputs.each do |variable|%>
  x[<%=getVarNum(circuit.var_list,variable)%>]=mgr.bddVar(<%=getVarNum(heur.order,variable)%>); //<%=variable%>
<%end %>

  //Outputs
<%=circuit.generatePrevOutPuts(heur.name)%>


<%if heur.group and circuit.minisat %>
  //Group
  <%circuit.extra_info.symmetric_groups.each do |group|%>
  Cudd_MakeTreeNode(mgr.getManager(),<%=first_variable_group(heur.order,group)%>,<%=group.variables.length%>,MTR_FIXED);
  <%end%>
  <%if circuit.type == "SPLOT" %>
   std::cerr<<"Calculated groups:"<<<%= circuit.extra_info.symmetric_groups.length %><<std::endl;
      <%i= 0%>
      <% circuit.extra_info.symmetric_groups.each do |group| %>
        <% i = i + 1 %>
        std::cerr<<"\t"<<"Group<%= i %>:<%= group.variables.to_s %>"<<std::endl;
      <%end%>
  <%end%>
<%end%>






  //Gates
  std::cerr<<"Generating bdd ..."<<std::endl;
  t1 = get_user_time();
  <%=circuit.generateClauses(calc_desc, heur.name,enable_autodyn)%>
  t2 = get_user_time();
  <%i=0%>
  t4 = get_diftime(t1,t2);

  <%if symmetricCheckVarAreSymmetric%>
  s_rootBDD =  x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>].getNode();
  <%end%>


  <%if heur.reorder != ""  %>
    <%if count_symmetric %>
      std::cerr<<"Counting symmetric ... "<<std::endl;
      symmetric = totalSymmetric(mgr,x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>],<%=circuit.dfs_inputs.size%>,<%=_count_symmetric%>,false);
    <%end%>
    <%if not enable_autodyn %>
      t1 = get_user_time();
      std::cerr<<"Reducing heap order <%=heur.name%> reorder <%=heur.reorder%> ..."<<std::endl;
      nodes_before = Cudd_DagSize(x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>].getNode());
      std::cerr<<"Nodes before reduce heap:"<<nodes_before<<std::endl;
      mgr.ReduceHeap(<%=heur.reorder%>);
      t2 = get_user_time();
      t3 = get_diftime(t1,t2);
      <%if count_symmetric %>
        std::cerr<<"Counting symmetric after reduce heap  ... "<<std::endl;
        symmetric_after = totalSymmetric(mgr,x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>],<%=circuit.dfs_inputs.size%>,<%=_count_symmetric%>,true);
      <%end%>
    <%else%>
      t3 = 0;
    <%end%>
  <%end%>

  <%if calc_desc %>
    ptotal[0] = x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>].getNode();
    std::cerr<<"Calculating dead_core complete .."<<std::endl;
    desc_t1 = get_user_time();
    feature_model_info* info2 = calc_dead_core_and_impact_exclusion_only_one(mgr.getManager(), ptotal[0], <%=circuit.dfs_inputs.size%>);
    desc_t2 = get_user_time();
    desc_t5 = get_diftime(desc_t1,desc_t2);


    desc_t2 = get_user_time();
    desc_t3 = get_diftime(desc_t1,desc_t2);
    desc_t1 = get_user_time();
    std::cerr<<"Calculating dead and core..."<<std::endl;
    feature_model_info* info1 =calc_dead_core_and_impact_exclusion(mgr.getManager(), poutput, <%=circuit.outputs.size()-1%>, <%=circuit.dfs_inputs.size%>);
    desc_t2 = get_user_time();
    desc_t4 = get_diftime(desc_t1,desc_t2);


    feature_model_info** pinfo = new feature_model_info*[<%=circuit.outputs.size%>];
    for(int i=0; i< <%=circuit.outputs.size-1%>;i++)
    {
    std::cerr<<"Calculation dead core function "<<i<<std::endl;
    pinfo[i] = calc_dead_core_and_impact_exclusion_only_one(mgr.getManager(), output[i].getNode(), <%=circuit.dfs_inputs.size%>);
    }


    for(int i=0; i < <%=circuit.outputs.size-1%>; i++){
    unsigned int nodes = Cudd_DagSize(poutput[i]);
    sum_nodes = sum_nodes + nodes;
    std::cerr<<"Nodes output["<<i<<"] = "<<nodes<<std::endl;
    }

    for(unsigned int i=0;i<<%=circuit.dfs_inputs.size%>;i++)
    {
    if(info2->var_low[i] == 1 && info2->var_high[i] == 0 )
    {
    dead = dead + 1;
    }
    if(info2->var_low[i] == 0 && info2->var_high[i] == 1 )
    {
    core = core + 1;
    }
    fprintf(stderr,"dead_core:%d\tinfo2:[%d,%d] info1: [%d,%d] ",i,info2->var_low[i],info2->var_high[i],info1->var_low[i],info1->var_high[i]);
    for(unsigned int j=0; j<<%=circuit.outputs.size-1%>;j++)
    {
    fprintf(stderr,"\tfunction(%d): [%d,%d]",j,pinfo[j]->var_low[i],pinfo[j]->var_high[i]);
    }
    if( info2->var_low[i] != info1->var_low[i] || info2->var_high[i] != info1->var_high[i] )
    fprintf(stderr,"\t****");
    fprintf(stderr,"\n");
    }
    fprintf(stderr,"Dead features: %u\n",dead);
    fprintf(stderr,"Core features: %u\n",core);
  <%end%>


  //Calc minterms at end
  minTerms =  x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>].CountMinterm(<%=circuit.dfs_inputs.size%>);



   <% if not calc_desc %>
      sprintf(buffer,"%g\t%g\t%g",t4,t3,minTerms);
   <% else %>
      sprintf(buffer,"%g\t%g\t%g\t%g\t%g\t%g\t%u\t%u\t%g\t%g",t4,t3,desc_t3,desc_t5,desc_t5+desc_t3,desc_t4,dead,core,sum_nodes,minTerms);
   <% end %>



  <%if count_symmetric %>
    std::cerr<<"Counting symmetric after reduce heap  ... "<<std::endl;
    symmetric_after = totalSymmetric(mgr,x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>],<%=circuit.dfs_inputs.size%>,<%=_count_symmetric%>,true);
  <%end%>




  str_output = "<%="#{heur.print_name}\t#{reorder}\t#{cpu_time[heur.name]}"%>";
  str_output = str_output + "\t" + buffer + "\t<%=span[heur.name]%>\t<%=circuit.extra_info.ecr%>\t<%=FunctionInfo.new(circuit).to_s%>";
  <%if count_symmetric %>
    str_output = str_output + "\t" + symmetric + "\t" + symmetric_after;
  <%end%>
  print_output(<%=circuit.var_list.size()%>,"<%=circuit.name%>",str_output,mgr,output,true,&(x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>]),<%=calcTotal(circuit)%>);
  writeSize("<%=grown_file%>", "<%=circuit.name%>", "<%=heur.name%>",count_nodes,count_id);

  <%if write_dot %>
  std::vector<BDD> dot_vector(<%=circuit.outputs.size()-1%>);
  <%(1..(circuit.outputs.size-1)).each do |i|%>
    dot_vector[<%=i-1%>] = output[<%=i-1%>];
  <%end%>
  FILE *fd = fopen("<%=circuit.name%>.dot","w");
  mgr.DumpDot(dot_vector,NULL,NULL,fd);
  fclose(fd);
  std::vector<BDD> dot_vector_total(1);
  dot_vector_total[0] =   x[<%=getVarNum(circuit.var_list,circuit.getNullFunction)%>];
  fd = fopen("<%=circuit.name%>_complete.dot","w");
  mgr.DumpDot(dot_vector_total,NULL,NULL,fd);
  fclose(fd);
  //<< ROB : 08/07/2018 Write also all extra information
  for(unsigned int j=0;j<<%= circuit.outputs.size - 1 %>;j++)
  {
    std::vector<BDD> func_vector(1);
    func_vector[0] = output[j];
    sprintf(buffer,"%d.dot",j);
    fd = fopen(buffer,"w");
    mgr.DumpDot(func_vector,NULL,NULL,fd);
    fclose(fd);
  }
  <%end%>




  kill(getppid(),SIGKILL);
  int status_parent;
  wait(&status_parent);
  exit(0);

}